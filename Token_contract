// Author: Aydin Abadi. The code is under MIT licence. 
pragma solidity ^0.4.4;

//Main contract
contract Token_Contract {

    address public owner;// the owner is the charity
	mapping (address => uint) public token_balances; // Given an address, it returns how many token an account/donor has.
	mapping (address => bool) public valid_master_contracts;//address of the valid master contract generated by the owner.
    mapping (address => uint) public num_donor_active_projects;// given a donor address it returns the total number of projects the donor created and engaged in the currect master contract.
    // we want to make sure pther contract created by  the charity cannot unlock a donor's locked tokens. 
    mapping (bytes6 => Locked_tok) public locked_tokens;
    struct Locked_tok{
        address donor_addr;
        address contract_addr;
        uint amount;
        bytes6 pro_id;
    }

	function Token_Contract() {
	    owner = msg.sender; // msg.sender is the address of the account sending a transaction to this contract
	}
    // Modifiers: allow to impose some restriction on a function.
    modifier onlyOwner {
        require (owner == msg.sender);
        _;
    }
    //the function is called by owner: anytime a new master contract is generated by the owner, it registers it in token_contract too.
   function register_valid_contract (address valid_contract) external onlyOwner  {
      valid_master_contracts[valid_contract] = true;
   }
    // This function allows the charity (owner of the contract) to distribute tokens among donors
   // We want this function to be executed only by the owner/creator of the contract, so we add tag onlyOwner to it. 
	//Also, the owner pays "amount" Ether to this contract. 
	//UI design : In the user interface, it needs to be checked if the charity is paying sufficient amouunt of Ether when it calls this function. 
	function assign_token_to_donor (address reciever, uint amount) external onlyOwner  {
		// increase the reciever1 credit
		token_balances[reciever] += amount;
	}
	  // UI desgin: below function can be purly impleented in UI, and no need to be implemented in this smart contract.
     // UI desgin: If this function is gonna be used in this contract, in UI the owner must pay/send some Ether to this function as well and this must be checked in UI.
	// Just for the sake of completeness the following function is implemented.
   function send_Eth (address donor_addr) external payable onlyOwner {
       require (msg.value == 5 ether);
       donor_addr.transfer (msg.value);
   }
   // returns the total number of tokens locked by donor for all master_contracts and projects he's engaged
   function get_donor_total_locked_tokens (address _donor_addr) external returns (uint sum){
       uint _count = num_donor_active_projects[_donor_addr];
       for (uint i = _count; i > 0; i--){
           bytes6 _id = gen_id (_donor_addr,i);
           sum += locked_tokens[_id].amount;
       }
       return sum;
   }
   // called by donor after he makes a project in a master contract.
    function assign_token_to_contract (uint _amount, address _master_contr_addr, bytes6 pro_id) external {
       require (token_balances[msg.sender] >= _amount);// checks if the donor has enough token in token_contract
       require (valid_master_contracts[_master_contr_addr] == true);// checks if the donor's assigning its tokens only to a valid contract
       Interface intf = Interface (_master_contr_addr);
       require (intf.get_project_creator(pro_id) == msg.sender);//checks if this donor has created a project in the master contract.
       //require (_amount < intf.max_allowed_tokens());// the donor cannot allocate tokens more than max_allowed_tokens for each project in master contract. 
       num_donor_active_projects[msg.sender] += 1;
       uint count = num_donor_active_projects[msg.sender];
       bytes6 _id = gen_id (msg.sender, count); // generates an new id for (donor, project) pair
       Locked_tok lt;
       lt.donor_addr = msg.sender;
       lt.contract_addr = _master_contr_addr;// setting this variable and pro_id by the donor prevents a malicious charity to create a valid contract and manipulate the donor's tokens.
       lt.amount += _amount; 
       lt.pro_id = pro_id;
       locked_tokens [_id] = lt;
       token_balances[msg.sender] -= _amount;
       intf.increment_tokens (msg.sender, _amount, pro_id);// asks the master contract to increment donors token in its  token_locked balance.
    }
    // Only  a valid master_contracts can call this function. 
    // note that even if the charity contructs a valid master_contract (other than the one donor allocated some tokens to), 
    //it cannot execute this function and manipulate its tokens. Because, this function checks if 
    // the donor has locked some token for that contract, and since the donor has done that directly (via token_contract) and specificed the desirable contract address
    // the other valid_contract cannot impersonate the contract to which the token has been assined.
    function tranfer_tokens (address _donor_addr, bytes6 pro_id, uint _amount, address benef_addr) external returns (bool res){
        bool temp;
        // only a valid master contract can call it. 
        require (valid_master_contracts[msg.sender] == true);
        // checks if the donor has already allocated _amount of tokens to pro_id for master contract:msg.sender.
        uint count = num_donor_active_projects[_donor_addr];
       for (uint i = count; i > 0; i--){
           bytes6 _id = gen_id (_donor_addr,i);
           if (_amount == locked_tokens[_id].amount && locked_tokens[_id].contract_addr == msg.sender && locked_tokens[_id].pro_id == pro_id){
               delete locked_tokens[_id]; //delete the donor's locked token for the project.
               temp = true;
               break;
           }}
       // increment beneficiary's tokens if the above check is passed.
       if (temp){
         token_balances[benef_addr] += _amount;
         res = true;
         }}

    function unlock_token (address _donor_addr, uint _amount, bytes6 pro_id) external returns (bool res){
        require (valid_master_contracts[msg.sender] == true);// checks if a valid contract is calling it. 
        uint val = num_donor_active_projects [_donor_addr];
        bytes6 _id;
        for (uint i = val;i > 0; i--){
           _id = gen_id (_donor_addr,i);
           // checks if the calling contract is the same as the one donor allocated its tokens. 
           if (_amount == locked_tokens[_id].amount &&  locked_tokens[_id].contract_addr == msg.sender && locked_tokens[_id].pro_id==pro_id){
               locked_tokens[_id].amount = 0;
               num_donor_active_projects[_donor_addr] -= 1;
               token_balances[_donor_addr] += _amount;
               res = true;
               break; 
           }}} 
          
      function gen_id (address _donor_adr,  uint val) internal returns (bytes6 res){
            res =   bytes6 (keccak256 (_donor_adr, val));
    }
// It prevents the fund to be locked forever in the contract forever. 
// *** We need to set some conditions (e.g. expiry date) when meet the owner can excute this function. Otherwise, it can call it at anytime and delete the donors tokens. 
    function destroy() external onlyOwner { 
       suicide (owner); 
   }}
   //Abstract contract
contract Interface{
  uint public max_allowed_tokens;
  function increment_tokens (address _donor, uint _amount, bytes6 pro_id);  
  function get_project_creator (bytes6 _id) external returns (address res);
}
