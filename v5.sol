// Author: Aydin Abadi. The code is under MIT licence. 
pragma solidity ^0.4.4;

//Main contract
contract Token_Contract {

    address public owner;// the owner is the charity
	mapping (address => uint) public token_balances; // Given an address, it returns how many token an account/donor has.
	mapping (address => bool) public valid_master_contracts;//address of the valid master contract generated by the owner.
    mapping (address => uint) public num_donor_active_projects;// given a donor address it returns the total number of projects the donor created and engaged in the currect master contract.
    // we want to make sure pther contract created by  the charity cannot unlock a donor's locked tokens. 
    mapping (bytes6 => Locked_tok) public locked_tokens;
    struct Locked_tok{
        address donor_addr;
        address contract_addr;
        uint amount;
        bytes6 pro_id;
    }

	function Token_Contract() {
	    owner = msg.sender; // msg.sender is the address of the account sending a transaction to this contract
	}
    // Modifiers: allow to impose some restriction on a function.
    modifier onlyOwner {
        require (owner == msg.sender);
        _;
    }
    //the function is called by owner: anytime a new master contract is generated by the owner, it registers it in token_contract too.
   function register_valid_contract (address valid_contract) external onlyOwner  {
      valid_master_contracts[valid_contract] = true;
   }
    // This function allows the charity (owner of the contract) to distribute tokens among donors
   // We want this function to be executed only by the owner/creator of the contract, so we add tag onlyOwner to it. 
	//Also, the owner pays "amount" Ether to this contract. 
	//UI design : In the user interface, it needs to be checked if the charity is paying sufficient amouunt of Ether when it calls this function. 
	function assign_token_to_donor (address reciever, uint amount) external onlyOwner  {
		// increase the reciever1 credit
		token_balances[reciever] += amount;
	}
	  // UI desgin: below function can be purly impleented in UI, and no need to be implemented in this smart contract.
     // UI desgin: If this function is gonna be used in this contract, in UI the owner must pay/send some Ether to this function as well and this must be checked in UI.
	// Just for the sake of completeness the following function is implemented.
   function send_Eth (address donor_addr) external payable onlyOwner {
       require (msg.value == 5 ether);
       donor_addr.transfer (msg.value);
   }
   // returns the total number of tokens locked by donor for all master_contracts and projects he's engaged
   function get_donor_total_locked_tokens (address _donor_addr) external returns (uint sum){
       uint _count = num_donor_active_projects[_donor_addr];
       for (uint i = _count; i > 0; i--){
           bytes6 _id = gen_id (_donor_addr,i);
           sum += locked_tokens[_id].amount;
       }
       return sum;
   }
   // called by donor after he makes a project in a master contract.
    function assign_token_to_contract (uint _amount, address _master_contr_addr, bytes6 pro_id) external {
       require (token_balances[msg.sender] >= _amount);// checks if the donor has enough token in token_contract
       require (valid_master_contracts[_master_contr_addr] == true);// checks if the donor's assigning its tokens only to a valid contract
       Interface intf = Interface (_master_contr_addr);
       require (intf.get_project_creator(pro_id) == msg.sender);//checks if this donor has created a project in the master contract.
       //require (_amount < intf.max_allowed_tokens());// the donor cannot allocate tokens more than max_allowed_tokens for each project in master contract. 
       num_donor_active_projects[msg.sender] += 1;
       uint count = num_donor_active_projects[msg.sender];
       bytes6 _id = gen_id (msg.sender, count); // generates an new id for (donor, project) pair
       Locked_tok lt;
       lt.donor_addr = msg.sender;
       lt.contract_addr = _master_contr_addr;// setting this variable and pro_id by the donor prevents a malicious charity to create a valid contract and manipulate the donor's tokens.
       lt.amount += _amount; 
       lt.pro_id = pro_id;
       locked_tokens [_id] = lt;
       token_balances[msg.sender] -= _amount;
       intf.increment_tokens (msg.sender, _amount, pro_id);// asks the master contract to increment donors token in its  token_locked balance.
    }
    // Only  a valid master_contracts can call this function. 
    // note that even if the charity contructs a valid master_contract (other than the one donor allocated some tokens to), 
    //it cannot execute this function and manipulate its tokens. Because, this function checks if 
    // the donor has locked some token for that contract, and since the donor has done that directly (via token_contract) and specificed the desirable contract address
    // the other valid_contract cannot impersonate the contract to which the token has been assined.
    function tranfer_tokens (address _donor_addr, bytes6 pro_id, uint _amount, address benef_addr) external returns (bool res){
        bool temp;
        // only a valid master contract can call it. 
        require (valid_master_contracts[msg.sender] == true);
        // checks if the donor has already allocated _amount of tokens to pro_id for master contract:msg.sender.
        uint count = num_donor_active_projects[_donor_addr];
       for (uint i = count; i > 0; i--){
           bytes6 _id = gen_id (_donor_addr,i);
           if (_amount == locked_tokens[_id].amount && locked_tokens[_id].contract_addr == msg.sender && locked_tokens[_id].pro_id == pro_id){
               delete locked_tokens[_id]; //delete the donor's locked token for the project.
               temp = true;
               break;
           }}
       // increment beneficiary's tokens if the above check is passed.
       if (temp){
         token_balances[benef_addr] += _amount;
         res = true;
         }}

    function unlock_token (address _donor_addr, uint _amount, bytes6 pro_id) external returns (bool res){
        require (valid_master_contracts[msg.sender] == true);// checks if a valid contract is calling it. 
        uint val = num_donor_active_projects [_donor_addr];
        bytes6 _id;
        for (uint i = val;i > 0; i--){
           _id = gen_id (_donor_addr,i);
           // checks if the calling contract is the same as the one donor allocated its tokens. 
           if (_amount == locked_tokens[_id].amount &&  locked_tokens[_id].contract_addr == msg.sender && locked_tokens[_id].pro_id==pro_id){
               locked_tokens[_id].amount = 0;
               num_donor_active_projects[_donor_addr] -= 1;
               token_balances[_donor_addr] += _amount;
               res = true;
               break; 
           }}} 
          
      function gen_id (address _donor_adr,  uint val) internal returns (bytes6 res){
            res =   bytes6 (keccak256 (_donor_adr, val));
    }
// It prevents the fund to be locked forever in the contract forever. 
// *** We need to set some conditions (e.g. expiry date) when meet the owner can excute this function. Otherwise, it can call it at anytime and delete the donors tokens. 
    function destroy() external onlyOwner { 
       suicide (owner); 
   }}
   //Abstract contract
contract Interface{
  uint public max_allowed_tokens;
  function increment_tokens (address _donor, uint _amount, bytes6 pro_id);  
  function get_project_creator (bytes6 _id) external returns (address res);
}




---------


// Author: Aydin Abadi. The code is under MIT licence. 
pragma solidity ^0.4.4;

// Main contact
contract Master_contract {
    
    address public token_contract_addr;// address of token_contract
    address public owner; // the contract owner/creator which is the charity.
    uint public num_of_beneficiaries;// total number of beneficiaries in this master contract. 
    uint public projects_count;//total number of project not canceled. 
    uint public max_allowed_tokens;// a donor cannot assign more token than max_allowed_tokens to a project
    uint public cont_validity_period; // the period within which the contract is valid.
    uint public cont_start_date; // the contract start date.
    uint public cont_expiry_date; // the contract expiry date.
    uint public num_of_validators;
    uint public num_of_required_validations;// number of validations required for a project to finalize.
    uint min_allowed_tokens;
    uint num_of_donors;// total number of donors engaged in this project so far. This counter allows us to retrive their address.
    uint id_counter;// total number of ids generated. it's used to delete the canceled id's in projects_ID_rep.
    uint  project_count;// total number of project made in this contract.
    mapping (uint => address) public validators_rep;
    mapping (uint => address)  public donors_rep;
    mapping (address => uint) public num_projects_donor_engaged;
    mapping (address => uint) public token_locked;// total number of tokens allocated to this contract by a donor.
    mapping (uint => address) public beneficiaries_addr;// valid beneficiaries addresses in this master contract. 
    mapping (bytes6 => Project) public projects_rep;// repository of projects created in this contract
    mapping (uint => bytes6) public projects_ID_rep;
    struct Project{
        mapping (uint => address) pro_validators_rep;// One may want to extract the validator input from validators_input_rep by using every validator in validators_rep. 
        // However, such approach as a  drawback: the input of a validator not engaged in a project and the one who proved false would be the same. 
        //also, for to let an auditor to audit each validator's input (no matter if it's true or flse) for each project we need to store the addr. of validators engaged in that project.
        mapping (address => bool) validators_input;// input of each validator to a project (i.e. true/false)
        address recipient_addr; // address of the token recipient
        address donor_addr; //  the address of the user who's created this poroject
        string desc; // The description provided by the user
        bytes6 ID;  // the project's unique id.
        bool token_transfered;// this value would become true, after the project is validated and the assigned tokens are transfered. 
        uint assined_tokens;// Number of tokens to be transfered to the recipient if the condition is met.
        uint pro_start_date; // the project start date
        uint pro_expiry_date;
        uint pro_cancelation_period; // // the period within which the user can cancel the project.
        uint num_of_validations; // the keeps the number of validations recived by a subset of validators
        uint num_of_validators_engaged;
    }

     modifier only_owner{
         require (msg.sender == owner);
         _;}
     // contructor   -- min_num_of_validations:  number of validators required to validate a project. 
    function Master_contract (uint num_of_validations, address _ben_addr, uint min_tokens, address _token_cont_addr, uint _cont_validity_period) public {
        owner = msg.sender; 
        num_of_beneficiaries++;
        beneficiaries_addr[num_of_beneficiaries] = _ben_addr;
        min_allowed_tokens = min_tokens;
        token_contract_addr = _token_cont_addr;
        cont_validity_period = _cont_validity_period; 
        cont_start_date = now; 
        cont_expiry_date = cont_start_date + cont_validity_period;
        num_of_required_validations = num_of_validations;
    }
    // allows the charity to add beneficiaries to this master contract.
    function add_beneficiary (address _ben_addr) external only_owner{
        //To prevent duplication, check if the new beneficiary has not already been registered.
        bool is_in;
        if (num_of_beneficiaries > 0){
        for (uint i = 1; i < num_of_beneficiaries + 1; i++){
            if (beneficiaries_addr[i]  == _ben_addr) {
                is_in = true;
                break;
            }}} 
        require (!is_in);
        num_of_beneficiaries++;
        beneficiaries_addr[num_of_beneficiaries] = _ben_addr;
    }
    
    function add_validators (address _validator_addr) external only_owner{
        //To prevent duplication, check if the new validator has not already been registered.
        bool is_in;
        if (num_of_validators > 0){
            for (uint i = 1; i < num_of_validators + 1; i++){
                 if (validators_rep[i] == _validator_addr){ 
                    is_in = true;
                    break;
                 }}}
        require (!is_in);
        num_of_validators++;
        validators_rep[num_of_validators] = _validator_addr;
    }
// when a donor creates a project it does not assign any token. In order to assing token it needs to call
//  assign_token_to_contract in token_contract. The latter function will assign the specified number of tokens to this project in master contract.
   function set_project (string description, uint _amount, address _deneficiaries_addr, uint val_period, uint cancelation_period) external  {
        // checks if the project creator has any token in the token_contract.
        require (_amount > min_allowed_tokens);
        Project memory pro;
        bool is_in;
        if (num_of_donors > 0){
            for (uint j = 1; j < num_of_donors + 1; j++){
                if (donors_rep[j] == msg.sender){
                    is_in = true;
                    break;
                }}}
        if (num_of_donors == 0 || is_in != true){
                num_of_donors++;
                donors_rep[num_of_donors] = msg.sender; 
            }
        num_projects_donor_engaged[msg.sender] += 1;
        //UI design: given donor address and num_projects_donor_engaged[msg.sender], it can get its project ID for each project_j, where 0<j<= num_projects_donor_engaged
        // note that it first needs to read the content of num_projects_donor_engaged. So re-generating the donor project_ID for each project it has created can be done in UI. 
        pro.ID = gen_id (msg.sender,this, num_projects_donor_engaged[msg.sender]);
        pro.pro_start_date = now;
        pro.pro_expiry_date = pro.pro_start_date + val_period;
        require (pro.pro_expiry_date < cont_expiry_date); // each project expiry date must be smalltr than the contract expiry date
        Token_Contract tc = Token_Contract (token_contract_addr);
        require (tc.token_balances(msg.sender) >= _amount);
       // checks if the donor is allocating its token to a valid recipient.
        bool is_valid_beneficiary;
        for (uint i = 1; i< num_of_beneficiaries + 1; i++){
            if (beneficiaries_addr[i] == _deneficiaries_addr){
                is_valid_beneficiary = true;
                break;
            }}
        require (is_valid_beneficiary);
        pro.donor_addr = msg.sender;
        pro.recipient_addr = _deneficiaries_addr;
        pro.desc = description;
        pro.pro_cancelation_period = cancelation_period;
        projects_rep[pro.ID] = pro;
        project_count++;
        projects_count++;
        id_counter++;
        projects_ID_rep[project_count] = pro.ID;
    }
 // Two conditions are checked (1) if the project's cancelation period has passed (2) the project is not expired yet.
     function check_project_conditions (bytes6 pro_id) internal returns (bool res){
        Project pro = projects_rep[pro_id];
         // condition (1) is checked 
        require (now > pro.pro_start_date + pro.pro_cancelation_period);
         // condition (2) is checked
        if (now < pro.pro_expiry_date){ 
           res = true;
        }}
            // if both conditions are met, return true.
    // given a project's ID, the validatro can insert it's input: true/false
    // if it's approved by "num_of_required_validations" validators, the token would be transfered to the beneficiary.
    function validate_project (uint _index, bool res)  external{
        //check if the caller is a legitimate validator.
        bool is_legit_valid;
        bool transfered; 
        //check if the validatros is legitimate.
        for (uint i = 1;i < num_of_validators + 1; i++){
            if (msg.sender == validators_rep[i]){
                is_legit_valid = true;
                break;
            }}
        require (is_legit_valid);
        // fetch the project ID.
        require (_index < project_count + 1);
        bytes6 project_id = projects_ID_rep[_index];
        bool is_in;
        Project pr = projects_rep[project_id];
        //each validator can validate only once, so make sure he has not already provided any input to this project.
        if (pr.num_of_validators_engaged > 0){
            for (uint j = 1;j < pr.num_of_validators_engaged + 1; j++ ){
                if (pr.pro_validators_rep[j] == msg.sender){
                    is_in = true;
                    break;
                }}}
        require (!is_in);    // so the validator shouldn't already participated in this project.    
        // it can validate only if some tokens have been allocated to this project.
        require (pr.assined_tokens > 0);
        pr.num_of_validators_engaged++;
        pr.pro_validators_rep[pr.num_of_validators_engaged] = msg.sender;
        pr.validators_input[msg.sender] = res;
        // it checks if the project conditions have been met,e.g. not expired yet, or is not in the project cancelation period.
        bool met = check_project_conditions (project_id);
        //the validator input is stored for this project.
        if (res) 
            pr.num_of_validations++;
        if (pr.num_of_validations == num_of_required_validations && met) {
          // If the project has been approved by num_of_required_validations, then the token is transfered to the recipient and decrement the donor token in the current contract is decremented.  
          Token_Contract tc = Token_Contract (token_contract_addr);
          transfered = tc.tranfer_tokens (pr.donor_addr, project_id, pr.assined_tokens, pr.recipient_addr);
          if (transfered){
              token_locked[pr.donor_addr] -= pr.assined_tokens;
              pr.token_transfered = true;
          }}}
    // It allows only the pro_creator to cancel the project if it's done within the valid cancelation_period
    function cancel_project (bytes6 project_id) external{
        Project pro = projects_rep[project_id];
        address creator = pro.donor_addr;// this is done to improve efficiency... 
        require (msg.sender == creator); // only the creator of the project can cancel it.
        require (now < pro.pro_start_date + pro.pro_cancelation_period);
        //if some tokens have already been assigned to the project, then unlock them in token_contract. 
        if (pro.assined_tokens > 0){
            Token_Contract tc = Token_Contract (token_contract_addr);
        // get the amount assigned by the donor for this project
            uint _amount = projects_rep[project_id].assined_tokens;
            require (tc.unlock_token (msg.sender, _amount, project_id));
            token_locked[msg.sender] -= _amount;
        }
        // find the id from  projects_ID_rep and delete it from projects_ID_rep.
        for (uint j = 1;j < id_counter + 1; j++){
            if ( projects_ID_rep[j] == project_id){
            delete projects_ID_rep[j];
            break;
            }}
        projects_count--;   
        num_projects_donor_engaged[msg.sender]--;
        //if the donor has no project in this master contract, remove its address from donors_rep.
        if (num_projects_donor_engaged[msg.sender] == 0){
            for (uint k = 1; k < num_of_donors + 1; k++){
                if (donors_rep[k] == msg.sender){
                    delete (donors_rep[k]);
                    break;
            }}}
        delete (projects_rep[project_id]); 
    }
    // is called by assign_token_to_contract() in token_contract.
    function increment_tokens (address _donor_addr, uint _amount, bytes6 pro_id) external{
        require (msg.sender == token_contract_addr);
        token_locked[_donor_addr] += _amount;
        projects_rep[pro_id].assined_tokens += _amount;
    }
    // Later on, if we want an auditor to check all the project to see why a validator did NOT valid a project, then we need to REMOVE the following two functionds. 
    //Allows anybody to remove an expired project (when either a project or master contract is expired) and refund the donor.
     function remove_an_expired_project (bytes6 _pro_id) external{
        Project memory pro = projects_rep[_pro_id];
        require (pro.token_transfered != true);// checks if the project's tokens have not been tranfered. 
        bool temp;
        Token_Contract tc = Token_Contract (token_contract_addr);
        if (pro.pro_expiry_date > now || cont_expiry_date > now){
            temp = tc.unlock_token (pro.donor_addr, pro.assined_tokens, pro.ID); //send back the allocated token to its owner
            if (temp){
                for (uint j = 1;j < id_counter + 1; j++){
                    if ( projects_ID_rep[j] == _pro_id)
                        delete projects_ID_rep[j];
                        break;
                }
                 delete (projects_rep[_pro_id]); //remove the project from the repository, i.e. set the projects_rep[id] to zero;
                 projects_count -= 1;// decrement the project_count by one.  
            }}} 
    //Allows any party to through the project repository, remove all the expired projects (when either a project or master contract is expired) and refund the donor. 
    function remove_all_expired_projects () external{
        bytes6 id;
        bool temp;
        Token_Contract tc = Token_Contract (token_contract_addr);
        for (uint i = 1; i < num_of_donors + 1; i++){
            address _don_adr = donors_rep[i];
            uint count = num_projects_donor_engaged[_don_adr];
            for (uint j = 1 ; j < count + 1; j++){
                id = gen_id (_don_adr, this, j);
                Project memory pro = projects_rep[id];
                if (!pro.token_transfered){
                    if (pro.pro_expiry_date > now || cont_expiry_date > now){
                        temp = tc.unlock_token (pro.donor_addr, pro.assined_tokens, pro.ID); 
                        if (temp){
                             for (uint k = 1;j < id_counter + 1; k++){
                                 if (projects_ID_rep[k] == id)
                                    delete projects_ID_rep[k];
                                    break;
                             }
                            delete (projects_rep[id]); 
                            projects_count -= 1; 
                    }}}}}}
    // it generates a uniqeu ID (with a high probability) for a donor's project. The ID is unique even if the donor generates multiple projects both within a master_contract and among all master contracts 
    function gen_id (address _donor_adr, address _cont_addr, uint val) internal returns (bytes6 res){
            res =   bytes6 (keccak256 (_donor_adr, _cont_addr, val));
    }
    
    function get_project_creator (bytes6 _id) external returns (address res){
        Project pro = projects_rep[_id];
        res = pro.donor_addr;
    }
    //the current implementation is suitable for the case where a validator will be hold accountable for the project he has validated, not for the ones he hasn't.
    // the latter case can be important, because some condition has taken place in the real world, but the validator has not validated it (i.e. it has ignored it). So the auditor may want to detect this kind of problems as well. 
}
 // Abstract contact
 contract Token_Contract{
     function unlock_token (address _donor_addr, uint _amount, bytes6 pro_id) external returns(bool res){}
     function get_locked_token_balance(address donor_addr, bytes6 pro_id) external returns (uint res){}
     function assign_token_to_contract (uint _amount, address _donor_addr) external returns (bool){}
     function tranfer_tokens (address _donor_addr, bytes6 pro_id, uint _amount, address benef_addr) external returns (bool res){}
     mapping (address => uint) public token_balances;
     struct Project_tc{
        address contract_addr;
        address donor_addr;// This may not needed. We put here for just compelteness.
        uint token_amount;
    }}